# -*- coding: utf-8 -*-
"""EDA.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1FjVrQ5a08RWBDxJk7u9FsKhxZALQgZU7
"""

import pandas as pd

# Cargar el archivo CSV
file_path = '/content/car_price_prediction.csv'
data = pd.read_csv(file_path)
data.head(5)

# Ver el n칰mero total de filas y columnas
print(data.shape)

# Ver la informaci칩n general sobre el dataset (tipos de datos, valores no nulos, etc.)
data.info()

# Ver estad칤sticas descriptivas (solo para columnas num칠ricas)
print(data.describe())

# Ver el n칰mero de valores 칰nicos en cada columna
print(data.nunique())

# Contar la cantidad de valores faltantes por columna
print(data.isnull().sum())

# 4. Revisar las columnas categ칩ricas (no num칠ricas) y sus valores 칰nicos
print("\nValores 칰nicos en las columnas categ칩ricas:")
for col in data.select_dtypes(include=['object']).columns:
    print(f"{col}: {data[col].unique()[:10]}")  # Muestra los primeros 10 valores 칰nicos

# 5. Revisar si hay filas duplicadas
print("\n쮼xisten filas duplicadas?:")
print(data.duplicated().sum())

# Eliminar filas duplicadas
data = data.drop_duplicates()

# 5. Revisar si hay filas duplicadas
print("\n쮼xisten filas duplicadas?:")
print(data.duplicated().sum())

# Eliminar la unidad 'km' de la columna Mileage y convertir a tipo num칠rico
data['Mileage'] = data['Mileage'].str.replace(' km', '').replace('-', None).astype(float)

data.head()

# Convertir 'Price', 'Levy', 'Cylinders', y 'Engine volume' a valores num칠ricos, manejando entradas no v치lidas
data['Price'] = pd.to_numeric(data['Price'], errors='coerce')
data['Levy'] = pd.to_numeric(data['Levy'], errors='coerce')
data['Cylinders'] = pd.to_numeric(data['Cylinders'], errors='coerce')
data['Engine volume'] = pd.to_numeric(data['Engine volume'], errors='coerce')

# Contar la cantidad de valores faltantes por columna
print(data.isnull().sum())

"""Se ha decidido rellenar los valores nulos de la columna **Levy** con **0** porque, en muchos casos, la ausencia de este dato puede indicar que el auto no est치 sujeto a ese impuesto o tarifa. Esto es m치s representativo que eliminar los datos o utilizar una estimaci칩n arbitraria.

En cuanto a la columna **Engine volume**, se ha rellenado con la **mediana** para mantener la integridad de los datos, ya que el tama침o del motor es un atributo clave del veh칤culo. La mediana es menos sensible a valores extremos, lo que evita distorsiones y asegura que los valores faltantes se aproximen a la mayor칤a de los autos del dataset.

Este enfoque mantiene la mayor cantidad posible de informaci칩n sin comprometer la calidad del an치lisis.
"""

# Rellenar valores nulos de 'Levy' con 0
data['Levy'].fillna(0, inplace=True)

# Rellenar valores nulos de 'Engine volume' con la mediana
data['Engine volume'].fillna(data['Engine volume'].median(), inplace=True)

# Verificar si los valores nulos han sido manejados
print(data.isnull().sum())

# Si deseas guardar el dataset limpio en un nuevo archivo CSV
output_path = '/content/car_price_prediction3.csv'
data.to_csv(output_path, index=False)

import matplotlib.pyplot as plt
import seaborn as sns

# Establecer estilo para las visualizaciones
sns.set(style="whitegrid")

# 1. Distribuci칩n de los Precios de los Autos
plt.figure(figsize=(10, 6))
sns.histplot(data['Price'], bins=50, kde=True)
plt.title('Distribuci칩n de los Precios de los Autos')
plt.xlabel('Precio')
plt.ylabel('Frecuencia')
plt.xlim(0, 100000)  # Limitando el eje x para enfocarse en la mayor칤a de los datos
plt.show()

# 2. A침o de Producci칩n vs. Precio (Gr치fico de dispersi칩n)
plt.figure(figsize=(10, 6))
sns.scatterplot(x='Prod. year', y='Price', data=data)
plt.title('Precio del Auto vs. A침o de Producci칩n')
plt.xlabel('A침o de Producci칩n')
plt.ylabel('Precio')
plt.ylim(0, 1000000)  # Limitando el eje y para enfocarse en la mayor칤a de los datos
plt.show()

# 3. Distribuci칩n del Volumen del Motor
plt.figure(figsize=(10, 6))
sns.histplot(data['Engine volume'], bins=30, kde=True)
plt.title('Distribuci칩n del Volumen del Motor')
plt.xlabel('Volumen del Motor')
plt.ylabel('Frecuencia')
plt.show()

# 4. Precio del Auto seg칰n el Tipo de Combustible
plt.figure(figsize=(10, 6))
sns.boxplot(x='Fuel type', y='Price', data=data)
plt.title('Distribuci칩n de Precios por Tipo de Combustible')
plt.xlabel('Tipo de Combustible')
plt.ylabel('Precio')
plt.ylim(0, 100000)  # Limitando el eje y para enfocarse en la mayor칤a de los datos
plt.show()

# 5. Precio del Auto seg칰n el Tipo de Caja de Cambios
plt.figure(figsize=(10, 6))
sns.boxplot(x='Gear box type', y='Price', data=data)
plt.title('Distribuci칩n de Precios por Tipo de Caja de Cambios')
plt.xlabel('Tipo de Caja de Cambios')
plt.ylabel('Precio')
plt.ylim(0, 100000)  # Limitando el eje y para enfocarse en la mayor칤a de los datos
plt.show()

"""Principales hallazgos de las visualizaciones:

Distribuci칩n de los precios de los autos:

La mayor칤a de los precios de los autos est치n concentrados por debajo de $100,000, con una ca칤da abrupta en la frecuencia a medida que el precio aumenta.
Hay algunos precios extremadamente altos, pero el enfoque principal est치 en autos asequibles.
Precio del auto vs. a침o de producci칩n:

Los precios generalmente aumentan con los a침os de producci칩n m치s recientes. Sin embargo, algunos modelos antiguos tienen precios m치s altos, probablemente debido a su estatus de lujo o autos cl치sicos.
La concentraci칩n de datos se encuentra alrededor de los a침os 2010-2020, lo que refleja que los autos modernos son m치s comunes en este conjunto de datos.
Distribuci칩n del volumen del motor:

La mayor칤a de los autos tienen vol칰menes de motor entre 1.5 y 3 litros.
Existen algunos valores at칤picos con vol칰menes de motor de hasta 20 litros, lo que podr칤a representar veh칤culos especializados o de lujo.
Precio del auto seg칰n el tipo de combustible:

Los autos h칤bridos y di칠sel tienden a tener una mayor variabilidad en sus precios, con los h칤bridos mostrando algunos de los precios m치s altos.
Los autos de gasolina tienen una distribuci칩n de precios m치s uniforme, mayormente en los rangos m치s bajos.
Precio del auto seg칰n el tipo de caja de cambios:

Los autos con cajas autom치ticas tienden a tener precios m치s altos en promedio, en comparaci칩n con aquellos con transmisiones manuales o de variador, lo que refleja quiz치 una preferencia por la comodidad en los autos modernos.
"""

plt.figure(figsize=(10, 6))
sns.scatterplot(x='Mileage', y='Price', data=data)
plt.title('Relaci칩n entre Kilometraje y Precio del Auto')
plt.xlabel('Kilometraje')
plt.ylabel('Precio')
plt.xlim(0, 500000)  # Limitar el kilometraje para evitar valores extremos
plt.ylim(0, 1000000)  # Limitar el precio
plt.show()

"""Relaci칩n entre kilometraje y precio:

No se observa una tendencia clara entre el kilometraje y el precio. Aunque existe una ligera relaci칩n negativa, hay muchos puntos dispersos. Esto sugiere que, adem치s del kilometraje, otros factores importantes (como el tipo de veh칤culo, la marca, o el a침o de producci칩n) tambi칠n afectan el precio.
"""

# Precio promedio por fabricante
plt.figure(figsize=(12, 6))
manufacturer_price = data.groupby('Manufacturer')['Price'].mean().sort_values(ascending=False)
sns.barplot(x=manufacturer_price.index, y=manufacturer_price.values)
plt.xticks(rotation=90)
plt.title('Precio Promedio por Fabricante')
plt.xlabel('Fabricante')
plt.ylabel('Precio Promedio')
plt.show()

"""Precio promedio por fabricante:

Fabricantes como Tesla, Porsche, y Lexus tienen precios promedio significativamente m치s altos que marcas como Chevrolet y Ford.
Los resultados reflejan que los fabricantes de lujo tienden a mantener precios elevados, mientras que las marcas m치s accesibles tienen precios promedio m치s bajos.
"""

plt.figure(figsize=(10, 6))
sns.boxplot(x='Category', y='Price', data=data)
plt.title('Distribuci칩n de Precios por Categor칤a de Veh칤culo')
plt.xlabel('Categor칤a de Veh칤culo')
plt.ylabel('Precio')
plt.ylim(0, 100000)  # Limitar el precio para enfocarnos en datos relevantes
plt.xticks(rotation=90)
plt.show()

"""Distribuci칩n de precios por categor칤a de veh칤culo:

Las categor칤as de autos de lujo como los Jeep y los Minivan muestran una amplia variaci칩n en el precio, lo que sugiere que estos tipos de veh칤culos pueden abarcar tanto autos de gama baja como alta.
En comparaci칩n, los Hatchback y Sed치n tienden a tener precios m치s uniformes y generalmente m치s bajos.
"""

# Identificaci칩n de outliers en el precio
plt.figure(figsize=(10, 6))
sns.boxplot(x='Price', data=data)
plt.title('Outliers en Precios de Autos')
plt.show()

# Identificaci칩n de outliers en el kilometraje
plt.figure(figsize=(10, 6))
sns.boxplot(x='Mileage', data=data)
plt.title('Outliers en Kilometraje de Autos')
plt.show()

"""Outliers en precios:

Hay varios valores at칤picos en los precios, con algunos autos extremadamente caros. Esto puede incluir autos de lujo o veh칤culos personalizados que no siguen la tendencia promedio.

Outliers en kilometraje:

Existen algunos outliers extremos en el kilometraje. Algunos autos tienen kilometrajes excesivamente altos, lo que podr칤a deberse a errores en los datos o a situaciones excepcionales (por ejemplo, autos de servicio pesado).
"""

plt.figure(figsize=(10, 6))
sns.boxplot(x='Fuel type', y='Price', data=data)
plt.title('Precio del Auto por Tipo de Combustible')
plt.xlabel('Tipo de Combustible')
plt.ylabel('Precio')
plt.ylim(0, 100000)  # Limitar el precio
plt.show()

"""Precio por tipo de combustible:
De acuerdo con el an치lisis:

Los autos di칠sel tienen el precio promedio m치s alto, seguidos de los h칤bridos enchufables y los veh칤culos de hidr칩geno.
Los autos de gasolina tienen un precio promedio de 17,391.
Sorprendentemente, los autos h칤bridos no tienen un precio tan alto como se esperaba, con un precio promedio de 10,845.
"""

plt.figure(figsize=(10, 6))
sns.boxplot(x='Airbags', y='Price', data=data)
plt.title('Relaci칩n entre Cantidad de Airbags y Precio del Auto')
plt.xlabel('N칰mero de Airbags')
plt.ylabel('Precio')
plt.ylim(0, 100000)  # Limitar el precio
plt.show()

"""Para la relaci칩n entre el n칰mero de airbags y el precio, seg칰n el gr치fico de caja y bigote que generamos anteriormente, las siguientes conclusiones pueden extraerse:

1. **Mayor n칰mero de airbags, precios m치s altos**:
   - En general, los autos con **m치s airbags** tienden a tener precios m치s altos. Esto es coherente con la idea de que los veh칤culos con m치s caracter칤sticas de seguridad suelen ser m치s costosos.
   
2. **Distribuci칩n uniforme para ciertos valores**:
   - Los autos con **6 airbags** parecen ser muy comunes, con una distribuci칩n de precios amplia, lo que sugiere que este es un n칰mero t칤pico de airbags para veh칤culos de gama media.
   - Los autos con **12 o m치s airbags** tienden a ser m치s caros, lo que indica que suelen pertenecer a veh칤culos de lujo o de alta gama.

3. **Precios bajos con pocos airbags**:
   - Los autos con **0 o 2 airbags** tienden a tener precios m치s bajos, lo cual es l칩gico ya que estos veh칤culos probablemente tienen menos caracter칤sticas de seguridad y son modelos m치s econ칩micos o antiguos.

4. **Variabilidad en los precios**:
   - Aunque en general m치s airbags se asocian con precios m치s altos, tambi칠n hay bastante variabilidad dentro de cada grupo. Esto sugiere que, adem치s del n칰mero de airbags, otros factores como el fabricante, la categor칤a del auto o el a침o de producci칩n tambi칠n tienen un impacto significativo en el precio.

En resumen, los resultados sugieren que un mayor n칰mero de airbags est치 correlacionado con precios m치s altos, pero no es el 칰nico factor determinante del precio.
"""

from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression
from sklearn.tree import DecisionTreeRegressor
from sklearn.ensemble import RandomForestRegressor
from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score
from sklearn.preprocessing import LabelEncoder
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

# Cargar los datos
df = data

# Preprocesamiento: Codificaci칩n de variables categ칩ricas
df_encoded = df.copy()

# Convertir las columnas categ칩ricas en variables num칠ricas
label_encoders = {}
categorical_columns = df_encoded.select_dtypes(include=['object']).columns

for col in categorical_columns:
    le = LabelEncoder()
    df_encoded[col] = le.fit_transform(df_encoded[col])
    label_encoders[col] = le

# Definir las caracter칤sticas (X) y la variable objetivo (y)
X = df_encoded.drop(columns=['Price', 'ID'])  # Excluimos 'Price' (target) y 'ID'
y = df_encoded['Price']

# Dividir los datos en conjunto de entrenamiento y prueba
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Entrenar los tres modelos

# 1. Regresi칩n Lineal
lr_model = LinearRegression()
lr_model.fit(X_train, y_train)
y_pred_lr = lr_model.predict(X_test)

# 2. 츼rbol de Decisi칩n
dt_model = DecisionTreeRegressor(random_state=42)
dt_model.fit(X_train, y_train)
y_pred_dt = dt_model.predict(X_test)

# 3. Random Forest
rf_model = RandomForestRegressor(n_estimators=100, random_state=42)
rf_model.fit(X_train, y_train)
y_pred_rf = rf_model.predict(X_test)

# Evaluar el rendimiento de los tres modelos
def evaluate_model(y_test, y_pred, model_name):
    mae = mean_absolute_error(y_test, y_pred)
    rmse = np.sqrt(mean_squared_error(y_test, y_pred))
    r2 = r2_score(y_test, y_pred)
    print(f'{model_name} - MAE: {mae:.2f}, RMSE: {rmse:.2f}, R: {r2:.2f}')

# Comparar los modelos
evaluate_model(y_test, y_pred_lr, "Regresi칩n Lineal")
evaluate_model(y_test, y_pred_dt, "츼rbol de Decisi칩n")
evaluate_model(y_test, y_pred_rf, "Random Forest")

import joblib

# Supongamos que 'best_model' es el modelo que quieres guardar.
joblib.dump(dt_model, '/content/modelo.pkl')

# Cargar el modelo
model = joblib.load('/content/modelo.pkl')

data5 = data.head(5)

features = data5[['Levy', 'Manufacturer', 'Model', 'Prod. year', 'Category', 'Leather interior', 'Fuel type', 'Engine volume', 'Mileage', 'Cylinders', 'Gear box type', 'Drive wheels', 'Doors', 'Wheel', 'Color', 'Airbags']]

# Convertir las columnas categ칩ricas en variables num칠ricas
label_encoders = {}
categorical_columns = data5.select_dtypes(include=['object']).columns

for col in categorical_columns:
    le = LabelEncoder()
    data5[col] = le.fit_transform(data5[col])
    label_encoders[col] = le

categorical_columns

# Realizar predicciones
predictions = model.predict(data5.drop(columns=['Price', 'ID']))

predictions

# Si deseas guardar el dataset limpio en un nuevo archivo CSV
output_path = '/content/car_price_prediction5.csv'
data5.to_csv(output_path, index=False)

"""Conclusi칩n:
El 츼rbol de Decisi칩n es el modelo que mejor predice el precio de los autos, ya que tiene el menor error absoluto medio (MAE) y un
洧녠
2
R
2
  positivo, lo que indica que explica mejor la variabilidad en los precios.
Aunque el Random Forest generalmente supera a los 치rboles de decisi칩n, en este caso, su configuraci칩n no fue 칩ptima y dio un rendimiento peor.
La Regresi칩n Lineal no es adecuada para este problema, dado que no captura bien las relaciones no lineales entre las caracter칤sticas y el precio.

Para mejorar el rendimiento del modelo de Random Forest, ajustaremos algunos hiperpar치metros clave, como el n칰mero de 치rboles (n_estimators), la profundidad m치xima del 치rbol (max_depth), y el n칰mero m칤nimo de muestras por hoja (min_samples_leaf). Adem치s, podemos probar otros enfoques como la validaci칩n cruzada para asegurar que el modelo no se sobreajuste.

Estrategia de ajuste de hiperpar치metros:
Grid Search: Se probar치n diferentes combinaciones de hiperpar치metros para encontrar la mejor configuraci칩n.
Validaci칩n cruzada: Usaremos validaci칩n cruzada para obtener una mejor estimaci칩n del rendimiento general del modelo.
"""

from sklearn.model_selection import GridSearchCV

# Definir el modelo de Random Forest
rf_model = RandomForestRegressor(random_state=42)

# Definir el grid de hiperpar치metros a probar
param_grid = {
    'n_estimators': [100, 200, 300],         # N칰mero de 치rboles en el bosque
    'max_depth': [10, 20, 30, None],         # Profundidad m치xima de los 치rboles
    'min_samples_split': [2, 5, 10],         # M칤nimo de muestras para dividir un nodo
    'min_samples_leaf': [1, 2, 4],           # M칤nimo de muestras en una hoja
    'bootstrap': [True, False]               # Si se usa muestreo con reemplazo
}

# Usar GridSearchCV para probar todas las combinaciones de hiperpar치metros
grid_search = GridSearchCV(estimator=rf_model, param_grid=param_grid, cv=3, n_jobs=-1, verbose=3)
grid_search.fit(X_train, y_train)

# Mostrar los mejores hiperpar치metros encontrados
print("Mejores hiperpar치metros encontrados:")
print(grid_search.best_params_)

# Predecir con el mejor modelo
best_rf_model = grid_search.best_estimator_
y_pred_best_rf = best_rf_model.predict(X_test)

# Evaluar el mejor modelo
evaluate_model(y_test, y_pred_best_rf, "Mejor Random Forest")